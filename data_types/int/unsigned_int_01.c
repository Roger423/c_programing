/*
当您将一个负数（有符号类型）赋值给一个无符号类型的变量时，最终的结果是确定的，并且遵循模运算 (Modular Arithmetic) 的规则。

简单来说，对于一个8位的无符号变量 u8 a（通常是 unsigned char），如果将 -1 赋值给它，最终 a 的值会是 255。

为什么会是255？
我们可以从两个层面来理解这个过程：数学层面和二进制层面。

1. 数学层面：模运算规则
C语言标准规定，当一个整数值被转换为一个无符号整数类型时，其结果是该值对 (U_MAX + 1) 取模后的余数。其中 U_MAX 是该无符号类型的最大值。

对于 u8 (8位无符号整数)，它的取值范围是 0 到 255。所以 U_MAX 是 255。

U_MAX + 1 就是 256。

我们要计算 -1 对 256 取模。在数学上，这相当于不断给 -1 加上 256，直到结果落入 [0, 255] 的范围内。

计算过程：-1 + 256 = 255。

所以，a 的值就是 255。

可以把这个过程想象成一个时钟。如果当前是0点，往前拨1小时（-1），就相当于到了23点。

2. 二进制层面：位的重新解释 (更直观)
这是在计算机内部实际发生的情况，通常更容易理解。

表示 -1: 计算机使用二进制补码 (Two's Complement) 来表示负数。在一个8位的系统中，-1 的二进制补码表示是 11111111。

（如何得到？原码 00000001 -> 反码 11111110 -> 补码 11111111）

赋值操作: 当你执行 u8 a = -1; 时，编译器会将 -1 的二进制表示 11111111 直接存入变量 a 所占的内存空间中。这个过程中，位的模式没有改变。

值的解释: 现在，变量 a 的类型是无符号的 (u8)。当程序需要读取 a 的值时，它会按照无符号整数的方式来解释 11111111 这个位模式。

对于无符号数，11111111 的计算方式是：
1*2^7 + 1*2^6 + 1*2^5 + 1*2^4 + 1*2^3 + 1*2^2 + 1*2^1 + 1*2^0
= 128 + 64 + 32 + 16 + 8 + 4 + 2 + 1
= 255

所以，最终 a 的值被解释为 255。
*/

#include <stdio.h>
#include <stdint.h> // 为了使用 u_int8_t (等同于 u8)

int main() {
    // u_int8_t 是一个标准的8位无符号整数类型
    uint8_t a = -1;
    uint8_t b = -2;
    uint8_t c = -128;

    printf("当 -1 赋值给 u8 时, a 的值是: %u\n", a); // %u 用于打印无符号整数
    printf("当 -2 赋值给 u8 时, b 的值是: %u\n", b); // 结果是 -2 + 256 = 254
    printf("当 -128 赋值给 u8 时, c 的值是: %u\n", c); // 结果是 -128 + 256 = 128

    return 0;
}

/*
输出结果：
当 -1 赋值给 u8 时, a 的值是: 255
当 -2 赋值给 u8 时, b 的值是: 254
当 -128 赋值给 u8 时, c 的值是: 128

总结
将负数赋值给无符号类型的变量，在C语言中并非“错误”或“未定义行为”，而是一个完全确定的转换过程。
其本质是二进制位的模式保持不变，但对这个模式的解释方式发生了改变，从有符号的补码解释方式，变成了无符号的直接数值解释方式。
*/