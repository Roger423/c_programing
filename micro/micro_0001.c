#define MOD_WRAP(val, divisor) \
    ( ((divisor) != 0 && ((divisor) & ((divisor) - 1)) == 0) ? ((val) & ((divisor) - 1)) : ((val) % (divisor)) )


/*
功能概述
MOD_WRAP 宏的功能是计算 val 对 divisor 取模（求余数），即 val % divisor。但它并非简单地直接使用 % 运算符，而是实现了一种 优化：

如果 divisor 是 2 的整数次幂 (例如 2, 4, 8, 16, 1024 ...)，它会使用一个效率极高的位运算 (&) 来完成取模。

如果 divisor 不是 2 的整数次幂，它会回退（fallback）到使用标准的、效率较低的取模运算符 (%)。

这个宏的本质是利用了计算机二进制的特性，在特定条件下用更快的指令替代较慢的指令。

实现原理分析
我们可以将这个宏拆解为三个部分来理解：一个三元运算符（A ? B : C），包括 条件部分(A)、“真”分支(B) 和 “假”分支(C)。

1. “假”分支（标准路径）：((val) % (divisor))
这是最容易理解的部分。如果条件不满足，宏就会展开为标准的取模运算。这确保了宏在任何情况下（只要divisor不为0）都能得到正确的结果，
但它使用的是常规的整数除法指令，相对较慢。

2. 条件部分（路径选择）：((divisor) != 0 && ((divisor) & ((divisor) - 1)) == 0)
这是宏的核心，它用来判断是否可以走优化的路径。这个条件由两部分组成：

(divisor) != 0
这是一个安全检查，确保除数不为零，避免程序因除零错误而崩溃。

((divisor) & ((divisor) - 1)) == 0
这是一个非常巧妙的位运算技巧，用于 判断一个正整数是否是 2 的整数次幂。

原理:

任何一个大于0的、2的整数次幂，其二进制表示必然是 一个 ‘1’ 后面跟着若干个 ‘0’。

例如： 4  是 0100

例如： 8  是 1000

例如： 16 是 10000

当这个数减 1 后，其二进制表示会变成 原来 ‘1’ 的位置变为 ‘0’，后面所有的 ‘0’ 都变为 ‘1’。

例如： 4-1 = 3  是 0011

例如： 8-1 = 7  是 0111

例如： 16-1 = 15 是 1111

将这两个数进行按位与 (&) 运算，因为 ‘1’ 的位置完全错开，所以结果必然是 0。

4 & 3  =>  0100 & 0011  =>  0000  (结果是 0)

8 & 7  =>  1000 & 0111  =>  0000  (结果是 0)

反例 (如果不是2的幂):

如果一个数不是2的幂，那么它的二进制表示中至少有两个 ‘1’。

例如： 6 是 0110

它减 1 后是 5，即 0101

6 & 5  =>  0110 & 0101  => 0100 (结果是 4，不为 0)

所以，((divisor) & ((divisor) - 1)) == 0 这个表达式能高效地判断出 divisor 是否为2的幂。

3. “真”分支（优化路径）：((val) & ((divisor) - 1))
当条件判断为真，即 divisor 是 2 的整数次幂时，宏就会展开为这个位运算。

原理:
当 divisor 是 2 的 N 次幂时（divisor=2^N），那么 val % divisor 的结果等价于取 val 二进制表示的 低 N 位。
而 divisor - 1 的二进制恰好是一个低 N 位全为 1 的掩码（mask）。

示例: 计算 27 % 8

divisor 是 8，是 2 的 3 次幂 (2^3)。满足优化条件。

divisor - 1 是 7。

val 是 27。

二进制计算：

val = 27  是 0001 1011

divisor - 1 = 7 是 0000 0111 (这是一个低3位为1的掩码)

27 & 7 => 0001 1011 & 0000 0111 => 0000 0011

结果 0000 0011 的十进制值是 3。

而 27 % 8 的结果也确实是 3。

这个位运算 (&) 通常只需要一个 CPU 时钟周期，而整数除法/取模 (%) 指令可能需要数十个甚至更多的时钟周期，因此性能提升非常显著。

总结
MOD_WRAP(val, divisor) 是一个经过高度优化的取模宏。它的工作流程是：

检查 divisor：判断 divisor 是否是一个非零的、2的整数次幂。

选择路径：

是：执行 (val) & (divisor - 1)，利用高效的位与运算完成取模。

否：执行 (val) % (divisor)，使用标准的取模运算符。

返回结果。

宏使用的注意事项
括号：宏定义中，所有的参数 val 和 divisor 以及整个表达式都被括号包围。这是非常好的实践，
可以防止在宏展开时因运算符优先级问题导致的意外错误。

副作用 (Side Effects)：宏是简单的文本替换。请注意，divisor 在宏中被使用了多次。
如果传入的表达式带有副作用（例如 MOD_WRAP(x, i++)），i++ 可能会被执行多次，导致非预期的行为。因此，传递给宏的参数最好不要有副作用。
*/

/*
当 divisor 是 2 的 N 次幂时（divisor=2^N），那么 val % divisor 的结果等价于取 val 二进制表示的 低 N 位。 

原理：
它根植于数字的基数表示法（Base Representation） 和 模运算（Modular Arithmetic） 的定义。

我们可以从两个层面来理解，一个是通过我们熟悉的十进制进行类比，另一个是进行严格的数学证明。

1. 通过十进制类比（直观理解）
在解释二进制（基数为2）之前，我们先看看更熟悉的十进制（基数为10）。

在十进制中，对一个数取模 10^N(10,100,1000,...)，结果就等于取这个数的末N位。

例如，对于数字 47325：

47325 % 10  (10^1) = 5。结果就是末 1 位数字。
47325 % 100 (10^2) = 25。结果就是末 2 位数字。
47325 % 1000(10^3) = 325。结果就是末 3 位数字。

为什么会这样？因为 47325 可以被写作：
47325 = 47000 + 325 = 47 * 1000 + 325

根据取模的定义（a % d 的结果是 a 除以 d 的余数），47 * 1000 这一部分是 1000 的整数倍，所以它除以 1000 的余数是 0。
因此，47325 % 1000 的结果就只取决于 325 % 1000，而 325 小于 1000，所以余数就是 325 本身。

计算机的二进制世界与此完全相同，只是把基数从 10 换成了 2。
所以，val % 2^N 就等价于取 val 这个二进制数的末 N 位。

2. 严格的数学原理解释
这个结论的数学基础是 整数除法算法（Division Algorithm）。该算法指出：

对于任何整数 val 和正整数 d（除数），都存在唯一的整数 q（商）和 r（余数），使得：
val = q * d + r
其中 0 <= r < d。
我们将这个余数 r 定义为 val % d。

现在，我们将这个算法应用到我们的问题中：

val 是任意整数。

除数 d 是 2^N。

所以，我们要寻找满足以下条件的 q 和 r：
val = q * 2^N + r，其中 0 <= r < 2^N。
这个 r 就是 val % 2^N 的结果。

任何一个正整数 val 都可以用其二进制形式表示为各项 2 的幂次之和：
val = ... + b_{N+1} * 2^{N+1} + b_{N} * 2^{N} + b_{N-1} * 2^{N-1} + ... + b_1 * 2^1 + b_0 * 2^0
（其中 bi 是第 i 位的比特，值为 0 或 1）

现在，我们可以把这个和式拆分成两个部分：高位部分（2^N及以上）和 低位部分（2^N以下）。

高位部分:
(... + b_{N+1} * 2^{N+1} + b_{N} * 2^{N})
我们可以从这一部分中提取公因数 2^N：
2^N * (... + b_{N+1} * 2^1 + b_N * 2^0)
括号里的部分 (... + b_{N+1}*2^1 + b_N*2^0) 是一个整数，我们把它记为 q。
所以，高位部分可以写成 q * 2^N。

低位部分:
(b_{N-1} * 2^{N-1} + ... + b_1 * 2^1 + b_0 * 2^0)
这部分的值就是 val 二进制表示的 低 N 位所代表的数值。我们把它记为 r。

r 的最大值是多少？当低N位（从 b0 到 bN−1）全为 1 时，r 取最大值。这个值是 2^N−1。
所以，r 的取值范围是 0 <= r <= 2^N - 1，也就是 0 <= r < 2^N。

现在，我们把 val 重新组合起来：
val = (高位部分) + (低位部分) = (q * 2^N) + r

我们发现，这个表达式完美地符合了整数除法算法 val = q * d + r 的形式，并且余数 r 的范围 0 <= r < 2^N 也完全符合要求。

因此，我们可以得出结论：
val % 2^N 的结果就是 r，而 r 正是 val 二进制表示的低N位所代表的数值。

这就是为什么 val % 2^N 等价于取 val 的低 N 位。 而在计算机中，取一个数的低N位可以通过与一个低N位全为1的掩码（即 2^N−1）
进行按位与（&）运算来高效实现。
*/