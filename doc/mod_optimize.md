🎯 问题：
在 C 代码中使用 a % b，当 b 是 2 的幂时，编译器是否会自动优化为更高效的位运算 a & (b - 1)？

✅ 答案简要：
是的，大多数现代编译器（如 GCC、Clang、MSVC）在开启优化选项（如 -O2 或 -O3）时，
会自动将 a % b 优化为 a & (b - 1)，前提是 b 是常数且是 2 的幂。

🧠 背后原理
模运算：

a % b
当 b = 2^n（如 2, 4, 8, 16...）时，可以用：

a & (b - 1)
来等价替代。

因为在二进制下：

b = 2^n => b-1 = 0b111...111（n 位）
所以 a & (b - 1) 会保留 a 的低 n 位，正好是 a % b 的结果。

🛠️ 编译器优化实例（GCC）
假设你有如下 C 代码：

int mod8(int a) {
    return a % 8;
}
使用 GCC 编译：

gcc -O2 -S mod.c -o mod.s

查看生成的汇编，你会看到：

mod8:
    and     eax, 7
    ret

说明编译器把 % 8 优化为了 & 7。

📌 条件限定：
--------------------------------------------------------------------------
条件	                           是否优化
--------------------------------------------------------------------------
b 是常数，且是 2 的幂	            ✅ 会优化
b 是常数，但不是 2 的幂	            ❌ 不会优化为位运算（会使用乘法倒数或除法）
b 是变量，运行时可变	            ❌ 编译器通常无法优化
没有开启优化选项（如 -O0）	         ❌ 不优化
开启优化选项（如 -O2, -O3）	         ✅ 会优化
--------------------------------------------------------------------------

⚠️ 小提示
你写 a % b 可读性好，不必手动写 a & (b - 1)，因为现代编译器做得比你手动写还好，甚至可以选择更适合目标架构的指令。

🧪 如果你想验证：
你可以用 godbolt.org（Compiler Explorer）：

int foo(int a) {
    return a % 16;
}
你会看到不同编译器（GCC, Clang）在不同优化等级下的汇编指令变化。

✅ 总结
✅ 编译器在优化级别较高时会自动将 % 优化为 &，如果 % 的除数是 2 的幂且为常数。

❌ 若除数为变量或非幂次常数，则不会用 & 优化。

✅ 建议写 a % b，保持代码可读性，优化交给编译器。

